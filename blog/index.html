<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Tom's Data Science Blog">
<meta name="viewport" content="width=device-width">
<title>Tom's Data Science Blog | Tom's Data Science Blog</title>
<link href="assets/css/all.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://tomwhi.github.io/">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/multilabel-classification-modified-loss/" type="text/html">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
            styles, `#sidebar-checkbox` for behavior. -->
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"><!-- Toggleable sidebar --><div class="sidebar" id="sidebar">
        <div class="sidebar-item">
          <img src="images/ProfilePic.png">
</div>
        
    <nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="archive.html">Archive</a>
        <a class="sidebar-nav-item" href="categories/">Tags</a>
        <a class="sidebar-nav-item" href="rss.xml">RSS feed</a>
    
    
    </nav>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          
    <h3 id="brand" class="masthead-title">
      <a href="https://tomwhi.github.io/" title="Tom's Data Science Blog" rel="home">Tom's Data Science Blog</a>
    </h3>

        </div>
      </div>

      <div class="container content" id="content">
        

<div class="posts">
    <article class="post h-entry post-text"><header><h1 class="post-title p-name"><a href="posts/multilabel-classification-modified-loss/" class="u-url">More efficient labelling via a modified loss function</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tom Whitington</span></p>
            <p class="dateline"><a href="posts/multilabel-classification-modified-loss/" rel="bookmark"><time class="post-date published dt-published" datetime="2023-02-03T11:22:00+01:00" title="2023-02-03 11:22">2023-02-03 11:22</time></a></p>
                <p class="commentline">
    
    <a href="posts/multilabel-classification-modified-loss/#disqus_thread" data-disqus-identifier="cache/posts/multilabel-modified-loss.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <h2>tl;dr</h2>
<p>One can dramatically reduce the cost of labelling data for a multi-label classifier, using a custom loss function adapted from binary cross entropy.</p>
<h2>Labelling data is expensive</h2>
<p>Supervised learning requires labelled data, and manually labelling examples - for example identifying categories for documents - can be expensive.</p>
<p>In the Contextual team at Schibsted, we use natural language processing and machine learning to derive value from text data, such as news articles from Schibsted media brands, including Aftonbladet, Afterposten, SvD, and VG. One of our products is a system for matching news articles to contextual advertising campaigns that make the matches using news article content, rather than user browsing history.</p>
<p>Brand safety is an important concern in contextual advertising: articles that are deemed brand unsafe for a given campaign should not be matched to it. We have investigated text classification as a way to ensure brand safety of contextual advertising campaigns. A challenge with this approach is that the subtantial cost of labelling when producing a training dataset for a multi-label text classifier.</p>
<p>This blog post presents how a custom loss function can be used to substantially reduce the burden of data labelling.</p>
<h2>Labelling for multi-label classification</h2>
<p>When training a multi-label classifier with supervised learning, one typically starts with a dataset of <em>N<sub>total</sub></em> examples, where each example includes the input item, together with a vector of <em>C</em> labels, where <em>C</em> is the number of categories. Producing such a dataset will require O(<em>N<sub>total</sub> x C</em>) time. Therefore, labelling data is particularly expensive for multi-label classification problems.</p>
<p>Given a suitable training dataset, the standard approach is to use the <a href="https://towardsdatascience.com/cross-entropy-for-classification-d98e7f974451">binary cross entropy loss function</a> when training a multi-label classifier. In pytorch, this is implemented in <a href="https://pytorch.org/docs/stable/generated/torch.nn.BCELoss.html#torch.nn.BCELoss"><code>torch.nn.BCELoss</code></a> and <a href="https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html"><code>torch.nn.BCEWithLogitsLoss</code></a>. <code>BCEWithLogitsLoss</code> is the same as <code>torch.nn.BCELoss</code> but with an initial sigmoid layer on the inputs, so that one can avoid numerical instability that can occur when working with (potentially tiny) probability values.</p>
<p>The <code>BCEWithLogitsLoss</code> function takes as input a batch of "logit" values (scores that can be converted to probabilities using the sigmoid function) - each with <em>N</em> rows and <em>C</em> columns - and corresponding labels, each label being 0 or 1 for the given example and category:
<img alt="BCE loss inputs" src="images/loss_function/BCELossInputs.png"></p>
<p>For a given item in the batch (<em>i.e.</em> a single row from <em>x</em> and <em>y</em>), the loss is given by the following formula:</p>
<p><img alt="BCE loss single item" src="images/loss_function/BCELossFormulaSingleItem.png"></p>
<p>Here, $\sigma$ is the element-wise logistic (sigmoid) function - so it is applied to each element of <em>x<sub>n</sub></em>. Here's an example of this computation for the first item in the batch from above:</p>
<p><img alt="Loss example calculation" src="images/loss_function/LossExampleCalculation.png"></p>
<p>The overall loss for a batch of data is then simply the mean of the loss scores for the individual items in the batch:</p>
<p><img alt="BCE mean calculation" src="images/loss_function/LossMeanCalculation.png"></p>
<p><em>Side-note: the negative log of a probability is known as the information content ("self information") of an event. So, l<sub>n</sub> ends up being the sum of the information content contributed by each of the categories.</em></p>
<h2>Leave out labels for input examples?</h2>
<p>The binary cross entropy loss function requires each item to be labelled for every category. However, <em><strong>it would be really nice</strong></em> to be able to leave out labels - perhaps even only labelling a single category per input example. This would make it much easier to accrue positive and negative examples.</p>
<p>There are at least two phases of data collection where such a technique could prove useful. When initially creating a training dataset, one could seek out candidate positive and negative examples for a given category, and then manually review them to confirm or flip the candidate label for each item. The technique could also prove useful when improving the dataset, as it would allow one to seek out particularly tricky postive and negative examples for a particular category, and to only have to label the given category for those examples.</p>
<p>If we don't have a technique allowing us to leave out labels, then we would be forced to provide labels for all other categories, which can increase the labelling burden by a factor of <em>C</em>.</p>
<p>A simple approach here would be to simply train <em>C</em> separate binary classifiers, and to combine them into one classifier after they are each trained individually. However, this approach is somewhat inelegant, and could be wasteful in terms of memory and compute. Furthermore, model weights are not shared, which means that there is no possibility for data from one task to inform the classifier for another task.</p>
<h2>Custom loss function</h2>
<p>One solution to this problem is to modify the binary cross entropy loss function to ignore specified categories when computing loss for a given input example. This can be implemented by specifying a label "mask" for each input example, as discussed <a href="https://github.com/keras-team/keras/issues/3893">here</a> and <a href="https://www.dlology.com/blog/how-to-multi-task-learning-with-missing-labels-in-keras/">here</a>.</p>
<p>Here, we illustrate this approach, focusing on the case where only a single category has a label for each training example. Using this approach, the new loss function still accepts logits as the input <em>x</em>, but the label matrix <em>y</em> is modified so that only one category has a label for a given input item, and every other category has a null label of <em>-1</em> for that input example.</p>
<p><img alt="Modified loss inputs" src="images/loss_function/ModifiedLossInputs.png"></p>
<p>The loss for a single item in a batch is then modified to only look at the logit score and label for the non-null category:</p>
<p><img alt="Modified loss single item" src="images/loss_function/ModifiedLossFormulaSingleItem.png"></p>
<p>Here's what that computation would look like for both items from the batch above:</p>
<p><img alt="Modified loss example calculation" src="images/loss_function/ModifiedLossExampleCalculation.png"></p>
<p>Ideally, we'd like to be able to cope with the more general requirement of masking zero or more categories for each input example, even though we may in practice only label one category for each example. The following code snippet implements this more general masking approach in pytorch:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">torch</span>

<span class="k">class</span> <span class="nc">BCEOnSelectedLogitLoss</span><span class="p">(</span><span class="n">_Loss</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">'mean'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BCEOnSelectedLogitLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reduction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># Extract a mask matrix from the labels matrix:</span>
        <span class="n">mask_symbol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">!=</span> <span class="n">mask_symbol</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Eliminate the mask value (-1) from the labels to avoid numerical problems</span>
        <span class="c1"># when inputting it to the original loss function:</span>
        <span class="n">labels_no_mask_values</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># Get the individual loss function contributions for each category and example:</span>
        <span class="n">loss_function</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">(</span><span class="n">reduce</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">loss_without_mask</span> <span class="o">=</span> <span class="n">loss_function</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">labels_no_mask_values</span><span class="p">)</span>

        <span class="c1"># Convert contributions to zero as indicated by the mask values:</span>
        <span class="n">loss_with_mask</span> <span class="o">=</span> <span class="n">loss_without_mask</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># Each unmasked category example will contribute equally to the final loss:</span>
        <span class="n">loss_mean</span> <span class="o">=</span> <span class="n">loss_with_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loss_mean</span>
</pre></div>

<p>A quick sanity check confirms that the loss function produces the same result when we run the original loss function on only the selected categories:</p>
<div class="code"><pre class="code literal-block"><span class="n">bce_loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">()</span>
<span class="n">logits_matrix1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">2.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">8.5</span><span class="p">]])</span>
<span class="n">labels_matrix1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bce_loss</span><span class="p">(</span><span class="n">logits_matrix1</span><span class="p">,</span> <span class="n">labels_matrix1</span><span class="p">))</span>

<span class="n">selected_bce_loss</span> <span class="o">=</span> <span class="n">BCEOnSelectedLogitLoss</span><span class="p">()</span>
<span class="n">logits_matrix2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">4.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">5.5</span><span class="p">,</span><span class="mf">6.5</span><span class="p">,</span><span class="mf">7.5</span><span class="p">,</span><span class="o">-</span><span class="mf">8.5</span><span class="p">]])</span>
<span class="n">labels_matrix2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">selected_bce_loss</span><span class="p">(</span><span class="n">logits_matrix2</span><span class="p">,</span> <span class="n">labels_matrix2</span><span class="p">))</span>
</pre></div>

<p>Output:</p>
<div class="code"><pre class="code literal-block">tensor(5.5395, dtype=torch.float64)
tensor(5.5395, dtype=torch.float64)
</pre></div>

<p>We gave this modified loss function a spin on an inhouse brand safety classfication dataset, with our model consisting of a simple embedding layer followed by a linear layer (adapted from the pytorch <a href="https://pytorch.org/tutorials/beginner/text_sentiment_ngrams_tutorial.html">text classification tutorial</a>, and similar to the <a href="https://fasttext.cc/docs/en/supervised-tutorial.html">FastText</a> architecture). We confirmed that performance is similar using <em>C</em> separate binary FastText classifiers, as judged by AUC for the individual classifiers.</p>
<p>So, this does indeed seem to be a viable approach for training a single multi-label classifier from a dataset where each item only includes a label for a single category: it works! ðŸ¥³</p>
<p><em>Note: Results are not shown - out of scope for this blogpost.</em></p>
<h2>Conclusion</h2>
<p>Using a custom loss function based on binary cross entropy, one can include selectively labelled examples, without having to label every category. This can reduce the labelling cost by a factor of <em>C = Number of categories</em>, when one only wishes to label a single category for each example. We applied this approach in the context of multilabel text classification, but it is equally applicable to other modalities, such as image data.</p>
<h3><em>Social media:</em></h3>
<p>If you would like to get in touch, here's my social media:</p>
<ul>
<li>LinkedIn: <a href="https://www.linkedin.com/in/tomwhitington">https://www.linkedin.com/in/tomwhitington</a>
</li>
<li>Twitter: <a href="https://twitter.com/Tom_Whitington">@Tom_Whitington</a>
</li>
<li>Mastodon: @tomwhitington@sigmoid.social</li>
</ul>
</div>
    </article><article class="post h-entry post-text"><header><h1 class="post-title p-name"><a href="posts/using-word-vectors-to-decipher-swedish-culture/" class="u-url">Using word vectors to decipher Swedish culture</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Tom Whitington</span></p>
            <p class="dateline"><a href="posts/using-word-vectors-to-decipher-swedish-culture/" rel="bookmark"><time class="post-date published dt-published" datetime="2017-01-01T17:01:43+01:00" title="2017-01-01 17:01">2017-01-01 17:01</time></a></p>
                <p class="commentline">
    
    <a href="posts/using-word-vectors-to-decipher-swedish-culture/#disqus_thread" data-disqus-identifier="cache/posts/word-embeddings-swedish-culture.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <h2>Intro</h2>
<p>Can culture be quantified? Taking for example a statement like:</p>
<p><em>"Society has become more liberal over the years."</em></p>
<p>or</p>
<p><em>"In Sweden it is particularly important not to brag."</em></p>
<p>How do we know whether these statements are accurate?</p>
<p>Such questions relating to culture often prove refractory to quantitative analysis. However, recent developments in natural language processing (NLP) are providing new avenues of investigation. For example, the development of high quality <a href="https://en.wikipedia.org/wiki/Word_embedding" target="_blank">word embeddings</a> provides a mechanism for quantifying the meaning of words, as derived from input text corpora.</p>
<p>Here, I present an attempt to use word vectors to analyse culture. In particular, I have analysed <a href="https://arxiv.org/abs/1301.3781" target="_blank">word2vec</a> word embeddings trained on English and Swedish wikipedia corpuses, to examine whether there are particular areas of expression that are enriched or depleted in one language compared to another.</p>
<p>Below, I explain the analysis. To skip straight to the nice meaty results, <a href="posts/using-word-vectors-to-decipher-swedish-culture/#results">click here</a>.</p>
<p><img alt="clusters aesthetic" src="images/WordVectors/All_Clusters_Aesthetic_v3.svg"></p>
<h2>Word2vec and machine translation</h2>
<p>Word2vec is very cool indeed. The method produces high dimensional word embeddings by training a neural network to predict words given their context, from an input text corpus. The resulting <a href="https://www.tensorflow.org/tutorials/word2vec/" target="_blank">word vectors</a> have interesting semantic properties. To take a famous example, if we take the vector for the word "King", subtract the vector for "man" and add the vector for "woman", we end up with a vector located close to the word "Queen".</p>
<p><a href="https://arxiv.org/abs/1309.4168" target="_blank">Mikolov <em>et al.</em></a> also found that the relative positioning of words in one language are preserved to some extent when taking their translations in a second language. The authors showed how this can facilitate machine translation of words: A <a href="https://en.wikipedia.org/wiki/Transformation_matrix" target="_blank">transformation matrix</a> can be trained, such that multiplication of a word vector in language <em>l</em><sub>query</sub> will result in a vector that is close (on average) to a suitable translation in language <em>l</em><sub>target</sub>.</p>
<p>This leads to my project. One could apply Mikolov's method to all words in language <em>l</em><sub>query</sub> such that they are comparable to words in language <em>l</em><sub>target</sub>. This would result in two word landscapes in high-dimensional space, which can themselves be compared for various properties. For example, one language may be enriched or depleted for specific areas of expression relative to another. I implemented this approach and used it to compare English and Swedish, with the aim of identifying interesting cultural differences.</p>
<h2>Implementing Mikolov <em>et al.</em>
</h2>
<p>The code I wrote for this project is available on <a href="https://github.com/tomwhi/nlp-stuff" target="_blank">GitHub</a>. I implemented the project as a series of small python scripts, which cobble together to form a <a href="https://github.com/tomwhi/nlp-stuff/blob/master/example_pipeline.sh" target="_blank">rough analysis pipeline</a>. I focused on completing the project, rather than on software engineering <em>per se</em>, so some of it is a bit rough and ready.</p>
<p>My work relies on the <a href="https://radimrehurek.com/gensim/" target="_blank">gensim</a> library, which includes amongst other things an implementation of the word2vec training algorithm. I found the library extremely intuitive and powerful.</p>
<p>I produced word vectors and a transformation matrix through the following steps:</p>
<ul>
<li>
<a href="https://github.com/tomwhi/nlp-stuff/blob/master/process_wiki.py" target="_blank">Processing</a> the wikipedia corpus for input to gensim, for both English and Swedish.</li>
<li>
<a href="https://github.com/tomwhi/nlp-stuff/blob/master/train_word2vec.py" target="_blank">Training</a> word2vec models using gensim, including short phrases in the vocabulary in addition to individual words.</li>
<li>
<a href="https://github.com/tomwhi/nlp-stuff/blob/master/filter_word2vec_on_vocab.py" target="_blank">Filtering</a> the resulting word vectors to only retain words in predefined English and Swedish vocabularies</li>
<li>
<a href="https://github.com/tomwhi/nlp-stuff/blob/master/run_microsoft_translation.py" target="_blank">Obtaining translations</a> for the most frequent words using the Microsoft translation API, to use for training the transformation matrix, and <a href="https://github.com/tomwhi/nlp-stuff/blob/master/retrieve_training_vectors.py">retrieving</a> corresponding word vector pairs.</li>
<li>
<a href="https://github.com/tomwhi/nlp-stuff/blob/master/derive_translation_matrix.py" target="_blank">Training</a> the transformation matrix, by implementing gradient descent with the loss function defined in <a href="https://arxiv.org/abs/1309.4168" target="_blank">Mikolov <em>et al.</em></a>:</li>
</ul>
<p><img alt="equation" src="images/WordVectors/Equation.png"></p>
<ul>
<li>Here, <em>W</em> is the translation matrix, <em>x</em><sub>i</sub> is the <em>i</em> th training word vector in the query language and <em>z</em><sub>i</sub> is the word vector for the corresponding translation. I used <a href="https://github.com/Theano/Theano" target="_blank">Theano</a> to implement the gradient descent in this step, and manually checked the partial derivatives on a small example matrix to make sure I got the same results as Theano (having not used Theano prior to this). I plotted the cost function with increasing training iterations in order to see how different training rates impacted the effectiveness of the gradient descent.</li>
<li>I then applied the transformation matrix to all Swedish word vectors to obtain corresponding vectors that are then comparable to the English word vectors.</li>
</ul>
<p>Inspecting some example words and their translations indicates that the translation works quite well, as illustrated by the shift in Swedish word vectors between Figure 1 and Figure 2:</p>
<p><em>Figure 1: Scatterplot showing a selection of English words (red) and their corresponding Swedish words (blue), connected by light grey lines, when the word vectors are projected onto the first two principal components derived from running <a href="https://en.wikipedia.org/wiki/Principal_component_analysis" target="_blank">PCA</a> on the English word vectors:</em>
<img alt="PC plot 1" src="images/WordVectors/PC_Plot_English_Swedish.png"><sub><sup><em><strong>Technical note</strong>: Swedish word vectors can be projected onto the English principal components 1 and 2, as the Swedish and English word vectors just happen to be the same length (400 elements). This is done in figure 1 simply to contrast against their updated positions as shown in figure 2, after the translation matrix is applied.</em></sup></sub></p>
<p><em>Figure 2: When I multiply the Swedish word vectors with the translation matrix, the word vectors move much close to their respective English counterparts:</em>
<img alt="PC plot 2" src="images/WordVectors/PC_Plot_English_Swedish_Translated.png"></p>
<h2>Mitigating the "curse of dimensionality"</h2>
<p>Given word vectors for English and Swedish (translated to English word vector coordinates), I now set out to compare the languages based on the positioning of the word vectors in high dimensional space. This was by far and away the trickiest and most time-consuming aspect of the project, and I ended up trying a few different approaches to the problem.</p>
<p>To get optimal performance, word vectors are high dimensional (typically hundreds of dimensions). The high dimensionality of the resulting data can cause various <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_blank">problems</a>. In this project, data sparsity was a particular problem: I needed to find a way to compare the English and Swedish word vector landscapes in spite of the great sparsity of the word vector instances. Given 400 dimensions, a volume in that space will typically contain few word vectors.</p>
<p>I tried applying <a href="https://en.wikipedia.org/wiki/Principal_component_analysis" target="_blank">PCA</a> and doing a comparison of word density in volumes defined by the resulting lower number of dimensions, and I tried out the <a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding" target="_blank">t-SNE</a> method too.</p>
<p>My goal was to identify areas of linguistic expression enriched in one language relative to another, and so I eventually decided I should define clusters of words within similar meaning, and then analyse those on aggregate. To do this, I used gensim to find the <a href="https://github.com/tomwhi/nlp-stuff/blob/master/get_closest_words.py" target="_blank">closest</a> 100 English word vectors for each English word, as defined by <a href="https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank">cosine similarity</a>. I then defined a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics" target="_blank">graph</a>) of word similarity, with words as nodes and edges between nodes if the two words have cosine similarity &gt; 0.5. Taking this graph as input, I ran the <a href="http://www.mapequation.org/code.html" target="_blank">InfoMap tool</a> to detect clusters of highly interconnected words. For each of the word clusters, I also calculated the median cosine similarity value to the closest Swedish word, considering all words in the cluster.</p>
<p>Using this approach produced more robust results compared with an approach analysing individual words in isolation.</p>
<h2>Highly translatable words</h2>
<p>I consider the median Swedish cosine similarity to be a proxy for the <em>translatability</em> of a given word cluster - <em>i.e.</em> word clusters with a high score contain words that typically have a good translation, whilst word clusters with a low score contain words with mostly poor translations.</p>
<p>Looking at the clusters with highest translatability, we can see that the clusters deal with universal concepts that are not tethered to culture, including numbers, physical positioning, time, or physical actions, as shown in Figure 3.</p>
<p><em>Figure 3: Clusters of similar English words (red nodes) with high median cosine similarity of their closest Swedish translations (blue nodes), defined through use of InfoMap. Visualisation generated with <a href="https://gephi.org" target="_blank">Gephi</a>. Edges between English word nodes indicate cosine similarity &gt; 0.5, whereas an edge to a Swedish word node indicates the translation with highest cosine similarity for the given English word. The size of Swedish word nodes is scaled to the maximum observed cosine similarity score for that word. Note: The numeric values associated with the Swedish words are a technical artefact, and can be ignored.</em></p>
<p><img alt="NegCntrlClusters" src="images/WordVectors/NegCntrl_Clusters.png"></p>
<h2>
<a name="results"></a>Cultural insights: The Jantelagen and the Swagman</h2>
<p>Some of the clusters with low translatability scores reveal potentially cultural differences between Swedish- and English-speaking populations. I considered the clusters in the lowest 10% of translatability (72 clusters in total), and present illustrative examples here (more extensive results are presented in the <a href="posts/using-word-vectors-to-decipher-swedish-culture/#appendix">appendix</a>).</p>
<p>One unspoken rule underpinning Scandinavian societies is the <a href="https://en.wikipedia.org/wiki/Law_of_Jante" target="_blank">"Jantelagen"</a>. Under the Jantelagen, it is taboo to promote oneself as having greater merit or achievement compared to others. As such, it is perhaps no surprise that English words such as <em>eclipsed</em>, <em>surpassed</em>, <em>rivaled</em>, <em>bettered</em> and <em>outpaced</em> are difficult to translate to Swedish equivalents (Figure 4).</p>
<p><em>Figure 4: English words that appear to violate the Swedish Jantelagen (see Figure 3 caption for legend).</em></p>
<p><img alt="Jantelagen cluster" src="images/WordVectors/Jantelagen_cluster_v1.png"></p>
<p>Scandinavian societies are also famous for being highly egalitarian - a concept extending beyond the Jantelagen itself. My method identifies several relevant clusters of English words that are indeed not very egalitarian in tone. In Figure 5 we can see a cluster of words containing various occupations. Some of these arguably exist solely for rich people to flaunt their wealth - such as <em>butlers</em> or <em>valets</em>, and others might be considered old fashioned, such as <em>housekeepers</em> or <em>homemakers</em>. In a similar vein, words like <em>profiteering</em>, <em>mongering</em>, <em>debased</em>, and <em>bullish</em> seem to run counter to ideals of equality.</p>
<p><em>Figure 5: English words and concepts that run counter to egalitarianism.</em></p>
<p><img alt="Egalitarianism cluster" src="images/WordVectors/Egalitarianism_cluster_v1.png"></p>
<p>Figure 6 shows a cluster of morality-related verbs such as <em>sinned</em> and <em>transgressed</em>, and a cluster of nouns/adjectives relating to virtues, including <em>valour</em> and <em>gallantry</em>. These are concepts that vary from culture to culture; such ideas could be considered pompous or pious depending on your point of view.</p>
<p><em>Figure 6: English words relating to virtue concepts that translate poorly to Swedish.</em></p>
<p><img alt="Pomposity cluster" src="images/WordVectors/Pomposity_clusters_v1.png"></p>
<p>Various English word clusters relating to north american sporting terminology (baseball, gridiron football) as well as famous computer games (<em>ultima</em>, <em>resident evil</em>) also translate poorly into Swedish (Figure 7). This is clearly an expected result, as Swedes simply revert to using the English terminology when discussing such topics.</p>
<p><em>Figure 7: Sporting/gaming terms that translate poorly to Swedish.</em>
<img alt="Sports cluster" src="images/WordVectors/Sports_cluster_v1.png"></p>
<p>Finally, as an Australian, here is my favourite result of all:</p>
<p><em>Figure 8: Archaic professions of the Australian bush</em></p>
<p><img alt="Swagman cluster" src="images/WordVectors/Swagman_cluster_v1.png"></p>
<p>Of course, most Swedes will have not the foggiest of what a <em>bushranger</em> or a <em>swagman</em> is. These words are all professions in the Australian outback, in colonial times. A <a href="https://en.wikipedia.org/wiki/Swagman" target="_blank">swagman</a> was someone a bit down on their luck, travelling around the Australian bush looking for work here and there (Figure 9).</p>
<p><em>Figure 9: A swagman</em></p>
<p><img alt="Swagman" src="images/WordVectors/swagman.jpg"></p>
<p>The method gets fairly close for "bushranger", coming up with the Swedish word "pirat" (which is equivelant to the English word "pirate"). <a href="https://en.wikipedia.org/wiki/Bushranger" target="_blank">Bushrangers</a> were people hiding in the bush to evade the authorities, occasionally fighting the police (Figure 10).</p>
<p><em>Figure 10: No, Swedes, that's not a SÃ¶dermalm hipster. It's Ned Kelly, Australia's most famous bushranger, with his home-made suit of armour!</em></p>
<p><img alt="Ned Kelly" src="images/WordVectors/Ned_Kelly_in_1880.png"></p>
<h2>Perspectives</h2>
<p>If someone asked me,</p>
<p><em>"What did you find, in your quest for the word vectors?"</em></p>
<p>I would answer:</p>
<p><img alt="illumination" src="illumination_subtitled.gif"></p>
<p>The project was a lot of fun and I have learnt some new skills whilst doing it, including how to analyse and visualise word vectors, and implementing the gradient descent using Theano.</p>
<p>I am reasonably confident in the veracity of my findings, with some caveats (see <a href="posts/using-word-vectors-to-decipher-swedish-culture/#appendix">appendix</a>). On the whole, this approach seems to turn up some genuine areas of linguistic expression that are enriched in one language relative to another (in this case English vs Swedish). By inspecting the sets of words enriched in English relative to Swedish, the method seems to produce insights into cultural differences between the English- and Swedish-speaking communities.</p>
<p>Rigorous quantification of something as hard-to-define as human culture has important and beneficial applications.</p>
<p>As for future follow on work. Word vectors are, indeed, very cool. But <a href="https://arxiv.org/abs/1506.06726" target="_blank">thought vectors</a> - are even cooler! The ability to quantify individual thoughts could be a boon to humanity when coupled with good visualisation techniques. They could (for example) be used to augment human's understanding of various topics, granting permanence and elucidating what is otherwise ephemeral and complex.</p>
<p>Thank you for reading!</p>
<p>UPDATE (2023-02-03): This whole blog post is in many ways hopelessly outdated. But in particular I want to make a remark regarding the above "thought vectors": Arguably better terms for this could be "sentence embeddings", "contextualized word embeddings" - the kind of thing you get out of BERT and similar large language models.</p>
<h2>Acknowledgements</h2>
<p>I wish to thank <a href="https://twitter.com/mattiasostmar" target="_blank">Mattias Ã–stmar</a> and <a href="https://twitter.com/mikaelhuss" target="_blank">Mikael Huss</a>, who provided great insights and feedback throughout the project.</p>
<h2>
<a name="appendix"></a>Appendix</h2>
<p>This analysis has all been carried out in my spare time, so I have not approached it from as many angles I perhaps otherwise would do. I believe it is quite rigorous on the whole, but there are some a few caveats that I feel are important to point out.</p>
<p>The first is a general point: this method ultimately reflects differences between the <em>corpora</em> underlying the two sets of word vectors compared. Thus it will only reflect true differences in culture when the corpora are comparable - if I took English wikipedia and compared it against Swedish twitter data, I imagine the results would primarily reflect differences between wikipedia and twitter, rather than Swedish and English. I found it was important to filter word vectors to exclude those that are not true Swedish or English words - otherwise the final results were polluted by gibberish.</p>
<p>Another caveat is the reliance of the final step on what is ultimately a manual interpretation of the results; I looked at the English-enriched word clusters and offered my interpretation based on what I know about the languages and cultures. There are clearly different ways to interpret the same results. Replication of this technique on other corpus and language pairings could determine how robust these findings are.</p>
<p>There are also some obvious artefacts in the final results. For example, several Swedish-depleted English word clusters were actually not English words, but were words from another language (Figure 11).</p>
<p><em>Figure 11: Artefact word clusters - foreign language clusters</em></p>
<p><img alt="Artefact clusters" src="images/WordVectors/Language_Artefact_clusters.svg"></p>
<p>Finally, the least-translatable 72 (10% of all) English word clusters also included some results that seem to reflect culture in some way, which didn't fit into the main results section above. Here they are:</p>
<p><em>Figure 12: Additional results of interest</em></p>
<p><img alt="Misc results" src="images/WordVectors/Misc_Or_For_Appendix.svg"></p>
<h3><em>Social media:</em></h3>
<p>If you would like to get in touch, here's my social media:</p>
<ul>
<li>LinkedIn: <a href="https://www.linkedin.com/in/tomwhitington">https://www.linkedin.com/in/tomwhitington</a>
</li>
<li>Twitter: <a href="https://twitter.com/Tom_Whitington">@Tom_Whitington</a>
</li>
<li>Mastodon: @tomwhitington@sigmoid.social</li>
</ul>
</div>
    </article>
</div>



    
       <script>var disqus_shortname="https-tomwhi-github-io-blog";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><footer id="footer"><p>Contents Â© 2023         <a href="mailto:thomaswhitington@gmail.com">Tom Whitington</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
    
    
            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
